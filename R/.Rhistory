xx1 <- xx2 <- seq(from=min(c(x1,x2)),to=max(c(x1,x2)),length=100)
xx12 <- expand.grid(xx1,xx2)
cf <- model$coefficients
#yy <- cf[1] + cf[2] * xx12[,1] + cf[3] * xx12[,2] + cf[4] * xx12[,1]^2 + cf[5] * xx12[,2]^2
yy <- predict(model, data.frame(x1=xx12[,1],x2=xx12[,2],x1sq=xx12[,1]^2,x2sq=xx12[,2]^2))
plot3d(x.time)
spheres3d(cbind(xx12[,1],xx12[,2],yy),col=2,radius=0.001)
spheres3d(x.time,col=3,radius=0.005)
}
eigen.out[[1]][1:10]
plot(eigen.out[[1]][1:100])
my.drect(0,-1,2)
dnorm(0,0,1)
n <- 2
my.drect <- function(x,min,max){
ret <- rep(0,length(x))
ret[which(x>= min & x <= max)] <- 1/(max-min)
return(ret)
}
n.sample <- 200
r <- runif(n.sample)
sd2s <- runif(n.sample)*0.5 + 1
m1 <- 0
sd1 <- 1
m2 <- 1
#sd2 <- 1
x <- seq(from=-7,to=7,length=1000)
ps <- matrix(0,n.sample,length(x))
for(i in 1:n.sample){
ps[i,] <- my.drect(x,-r[i],2) +  dnorm(x,m2,sd2s[i])
}
ps <- ps/apply(ps,1,sum)
matplot(x,t(ps),type="l")
ipmat <- ps %*% t(ps)
logipmat <- log(ipmat)/2
eigen.out <- eigen(logipmat)
plot(eigen.out[[1]])
plot(eigen.out[[1]][1:100])
cols <- c(1:n,length(eigen.out[[1]]))
x.time <- t(t(eigen.out[[2]][,cols]) * sqrt(abs(eigen.out[[1]][cols])))
# time座標が正になるか負になるかはeigen()関数ではコントロールできないので
# 出力後に正に調整する
x.time <- sign(x.time[1,2]) * x.time
if(n==1){
plot(x.time[,1],x.time[,2])
}else if(n==2){
plot3d(x.time)
}
if(n==1){
y <- x.time[,length(x.time[1,])]
x <- x.time[,1]
model <- lm(y ~ poly(x,2))
plot(x,y)
abline(0,1)
abline(0,-1)
xx <- seq(from=min(c(x,y)),to=max(c(x,y)),length=100)
lines(xx, predict(model, data.frame(x=xx)), col='blue')
}else if(n==2){
y <- x.time[,length(x.time[1,])]
x1 <- x.time[,1]
x2 <- x.time[,2]
x1sq <- x1^2
x2sq <- x2^2
df <- data.frame(x1=x1,x2=x2,x1sq=x1sq,x2sq=x2sq)
model <- lm(y ~ x1 + x2 + x1sq + x2sq)
xx1 <- xx2 <- seq(from=min(c(x1,x2)),to=max(c(x1,x2)),length=100)
xx12 <- expand.grid(xx1,xx2)
cf <- model$coefficients
#yy <- cf[1] + cf[2] * xx12[,1] + cf[3] * xx12[,2] + cf[4] * xx12[,1]^2 + cf[5] * xx12[,2]^2
yy <- predict(model, data.frame(x1=xx12[,1],x2=xx12[,2],x1sq=xx12[,1]^2,x2sq=xx12[,2]^2))
plot3d(x.time)
spheres3d(cbind(xx12[,1],xx12[,2],yy),col=2,radius=0.001)
spheres3d(x.time,col=3,radius=0.005)
}
n <- 2
my.drect <- function(x,min,max){
ret <- rep(0,length(x))
ret[which(x>= min & x <= max)] <- 1/(max-min)
return(ret)
}
n.sample <- 200
r <- runif(n.sample)
sd2s <- runif(n.sample)*0.5 + 1
m1 <- 0
sd1 <- 1
m2 <- 1
#sd2 <- 1
x <- seq(from=-7,to=7,length=1000)
ps <- matrix(0,n.sample,length(x))
for(i in 1:n.sample){
ps[i,] <- r[i]*my.drect(x,-2,2) + (1-r[i]) * dnorm(x,m2,sd2s[i])
}
ps <- ps/apply(ps,1,sum)
matplot(x,t(ps),type="l")
ipmat <- ps %*% t(ps)
logipmat <- log(ipmat)/2
eigen.out <- eigen(logipmat)
plot(eigen.out[[1]])
plot(eigen.out[[1]][1:100])
cols <- c(1:n,length(eigen.out[[1]]))
x.time <- t(t(eigen.out[[2]][,cols]) * sqrt(abs(eigen.out[[1]][cols])))
# time座標が正になるか負になるかはeigen()関数ではコントロールできないので
# 出力後に正に調整する
x.time <- sign(x.time[1,2]) * x.time
if(n==1){
plot(x.time[,1],x.time[,2])
}else if(n==2){
plot3d(x.time)
}
if(n==1){
y <- x.time[,length(x.time[1,])]
x <- x.time[,1]
model <- lm(y ~ poly(x,2))
plot(x,y)
abline(0,1)
abline(0,-1)
xx <- seq(from=min(c(x,y)),to=max(c(x,y)),length=100)
lines(xx, predict(model, data.frame(x=xx)), col='blue')
}else if(n==2){
y <- x.time[,length(x.time[1,])]
x1 <- x.time[,1]
x2 <- x.time[,2]
x1sq <- x1^2
x2sq <- x2^2
df <- data.frame(x1=x1,x2=x2,x1sq=x1sq,x2sq=x2sq)
model <- lm(y ~ x1 + x2 + x1sq + x2sq)
xx1 <- xx2 <- seq(from=min(c(x1,x2)),to=max(c(x1,x2)),length=100)
xx12 <- expand.grid(xx1,xx2)
cf <- model$coefficients
#yy <- cf[1] + cf[2] * xx12[,1] + cf[3] * xx12[,2] + cf[4] * xx12[,1]^2 + cf[5] * xx12[,2]^2
yy <- predict(model, data.frame(x1=xx12[,1],x2=xx12[,2],x1sq=xx12[,1]^2,x2sq=xx12[,2]^2))
plot3d(x.time)
spheres3d(cbind(xx12[,1],xx12[,2],yy),col=2,radius=0.001)
spheres3d(x.time,col=3,radius=0.005)
}
out <- matrix(unlist(apply(x.time,1,my.pdisk.coords.R)),ncol=2,byrow=TRUE)
dim(out)
n
dim(x.time)
out <- matrix(unlist(apply(x.time,1,my.pdisk.coords.R)),ncol=n+1,byrow=TRUE)
x.poincare <- out[,1]
R <- out[,2]
#out. <- apply(cbind(rep,0,length(x.time[,1]),x.time),1,my.pdisk.coords)
plot(x.poincare)
out <- matrix(unlist(apply(x.time,1,my.pdisk.coords.R)),ncol=n+1,byrow=TRUE)
x.poincare <- out[,1]
R <- out[,2]
if(n==1){
plot(x.poincare,R)
}else if(n==2){
plot3d(cbind(x.poincare,R))
}
#out. <- apply(cbind(rep,0,length(x.time[,1]),x.time),1,my.pdisk.coords)
plot(R)
range(R)
plot(x.poincare)
out <- matrix(unlist(apply(x.time,1,my.pdisk.coords.R)),ncol=n+1,byrow=TRUE)
x.poincare <- out[,1:n]
R <- out[,2]
if(n==1){
plot(x.poincare,R)
}else if(n==2){
plot3d(cbind(x.poincare,R))
}
#out. <- apply(cbind(rep,0,length(x.time[,1]),x.time),1,my.pdisk.coords)
plot(x.poincare)
range(R)
out <- matrix(unlist(apply(x.time,1,my.pdisk.coords.R)),ncol=n+1,byrow=TRUE)
x.poincare <- out[,1:n]
R <- out[,n+1]
if(n==1){
plot(x.poincare,R)
}else if(n==2){
plot3d(cbind(x.poincare,R))
}
#out. <- apply(cbind(rep,0,length(x.time[,1]),x.time),1,my.pdisk.coords)
plot(x.poincare)
out <- matrix(unlist(apply(x.time,1,my.pdisk.coords.R)),ncol=n+1,byrow=TRUE)
x.poincare <- out[,1:n]
R <- out[,n+1]
if(n==1){
plot(x.poincare,R)
}else if(n==2){
t <- seq(from=0,to=1,length=100)*2*pi
plot(cos(t),sin(t),type="l")
points(x.poincare,pch=20,cex=0.1)
plot3d(cbind(x.poincare,R))
}
#out. <- apply(cbind(rep,0,length(x.time[,1]),x.time),1,my.pdisk.coords)
out <- matrix(unlist(apply(x.time,1,my.pdisk.coords.R)),ncol=n+1,byrow=TRUE)
x.poincare <- out[,1:n]
R <- out[,n+1]
if(n==1){
plot(x.poincare,R)
}else if(n==2){
t <- seq(from=0,to=1,length=100)*2*pi
plot(cos(t),sin(t),type="l")
points(x.poincare,pch=20,cex=0.1)
plot3d(cbind(x.poincare,R))
}
#out. <- apply(cbind(rep,0,length(x.time[,1]),x.time),1,my.pdisk.coords)
out <- matrix(unlist(apply(x.time,1,my.pdisk.coords.R)),ncol=n+1,byrow=TRUE)
x.poincare <- out[,1:n]
R <- out[,n+1]
if(n==1){
plot(x.poincare,R)
}else if(n==2){
t <- seq(from=0,to=1,length=100)*2*pi
plot(cos(t),sin(t),type="l",asp=TRUE)
points(x.poincare,pch=20,cex=0.1)
plot3d(cbind(x.poincare,R))
}
#out. <- apply(cbind(rep,0,length(x.time[,1]),x.time),1,my.pdisk.coords)
library(knitr)
library(rgl)
knit_hooks$set(webgl = hook_webgl)
# R=1の場合
my.pdisk.coords <- function(x){
x. <- x[1]/(x[3]+1)
y. <- x[2]/(x[3]+1)
return(c(x.,y.))
}
# 円板上の点の座標をx^2 + y^2 - z^2 = -1 という双曲面上に逆写像する
my.pdisk.coords.inv <- function(x){
z <- (1+sum(x^2))/(1-sum(x^2))
tmp <- 2*x/(1-sum(x^2))
return(c(tmp,z))
}
# 任意のRの場合
my.pdisk.coords.R <- function(x){
t <- x[length(x)]
x. <- x[-length(x)]
R <- sqrt(-sum(x^2) + 2 * t^2)
u <- R*x./(R+t)
return(list(u=u,R=R))
}
my.pdisk.coords.inv.R <- function(u,R){
t <- R * (R^2+sum(u^2))/(R^2-sum(u^2))
x. <- 2*R^2*u/(R^2-sum(u^2))
return(c(x.,t))
}
my.hyp.dist1 <- function(P,Q){
out <- my.orth.circle2(P,Q)
r <- out$r
d.ctr <- sqrt(sum(out$ctr^2)) # 原点から測地線円の中心までの距離
theta <- acos(1/d.ctr)
phi <- Arg(out$ctr[1] + 1i * out$ctr[2]) # 測地線円方向の角度
AB1 <- c(cos(phi-theta),sin(phi-theta))
AB2 <- c(cos(phi+theta),sin(phi+theta))
AQ <- sqrt(sum((AB1-Q)^2))
PB <- sqrt(sum((P-AB2)^2))
AP <- sqrt(sum((AB1-P)^2))
QB <- sqrt(sum((Q-AB2)^2))
# A,BをAB1,AB2のどちらにするか、２通りで距離を算出する
dhyp1 <- log(AQ*PB/(AP*QB))
dhyp2 <- log(QB*AP/(PB*AQ))
return(list(dhyp1=dhyp1,dhyp2=dhyp2,A=AB1,B=AB2,circle=out))
}
my.hyp.dist2 <- function(P,Q){
r <- 1
PQ <- sqrt(sum((P-Q)^2))
OP <- sqrt(sum((P)^2))
OQ <- sqrt(sum((Q)^2))
dhyp <- acosh(1+2*PQ^2*r^2/((r^2-OP^2)*(r^2-OQ^2)))
return(dhyp)
}
my.hyp.dist <- function(u,v){
acosh(- sum(u*v) + 2*u[length(u)]*v[length(v)])
}
my.hyp.dist3 <- function(P,Q){
P.hyp.cds <- my.pdisk.coords.inv(P)
Q.hyp.cds <- my.pdisk.coords.inv(Q)
return(my.hyp.dist(P.hyp.cds,Q.hyp.cds))
}
my.hyp.dist3.R <- function(P,Q,Rp,Rq){
P.hyp.cds <- my.pdisk.coords.inv.R(P,Rp)
Q.hyp.cds <- my.pdisk.coords.inv.R(Q,Rq)
}
V1 <- c(0,0,1)
V2 <- c(0,0,2)
P1 <- my.hyp.dist3.R(V1)
P1 <- my.pdisk.coords.R(V1)
P2 <- my.pdisk.coords.R(V2)
P1
P2
my.hyp.dist3.R(c(0,0),c(0,0),1,2)
library(knitr)
library(rgl)
knit_hooks$set(webgl = hook_webgl)
# R=1の場合
my.pdisk.coords <- function(x){
x. <- x[1]/(x[3]+1)
y. <- x[2]/(x[3]+1)
return(c(x.,y.))
}
# 円板上の点の座標をx^2 + y^2 - z^2 = -1 という双曲面上に逆写像する
my.pdisk.coords.inv <- function(x){
z <- (1+sum(x^2))/(1-sum(x^2))
tmp <- 2*x/(1-sum(x^2))
return(c(tmp,z))
}
# 任意のRの場合
my.pdisk.coords.R <- function(x){
t <- x[length(x)]
x. <- x[-length(x)]
R <- sqrt(-sum(x^2) + 2 * t^2)
u <- R*x./(R+t)
return(list(u=u,R=R))
}
my.pdisk.coords.inv.R <- function(u,R){
t <- R * (R^2+sum(u^2))/(R^2-sum(u^2))
x. <- 2*R^2*u/(R^2-sum(u^2))
return(c(x.,t))
}
my.hyp.dist1 <- function(P,Q){
out <- my.orth.circle2(P,Q)
r <- out$r
d.ctr <- sqrt(sum(out$ctr^2)) # 原点から測地線円の中心までの距離
theta <- acos(1/d.ctr)
phi <- Arg(out$ctr[1] + 1i * out$ctr[2]) # 測地線円方向の角度
AB1 <- c(cos(phi-theta),sin(phi-theta))
AB2 <- c(cos(phi+theta),sin(phi+theta))
AQ <- sqrt(sum((AB1-Q)^2))
PB <- sqrt(sum((P-AB2)^2))
AP <- sqrt(sum((AB1-P)^2))
QB <- sqrt(sum((Q-AB2)^2))
# A,BをAB1,AB2のどちらにするか、２通りで距離を算出する
dhyp1 <- log(AQ*PB/(AP*QB))
dhyp2 <- log(QB*AP/(PB*AQ))
return(list(dhyp1=dhyp1,dhyp2=dhyp2,A=AB1,B=AB2,circle=out))
}
my.hyp.dist2 <- function(P,Q){
r <- 1
PQ <- sqrt(sum((P-Q)^2))
OP <- sqrt(sum((P)^2))
OQ <- sqrt(sum((Q)^2))
dhyp <- acosh(1+2*PQ^2*r^2/((r^2-OP^2)*(r^2-OQ^2)))
return(dhyp)
}
my.hyp.dist <- function(u,v){
acosh(- sum(u*v) + 2*u[length(u)]*v[length(v)])
}
my.hyp.dist.R <- function(u,v){
ip <- - sum(u*v) + 2*u[length(u)]*v[length(v)]
normu <- - sum(u*u) + 2*u[length(u)]*u[length(u)]
normv <- - sum(v*v) + 2*v[length(v)]*v[length(v)]
acosh(ip/sqrt(normu*normv))
}
my.hyp.dist3 <- function(P,Q){
P.hyp.cds <- my.pdisk.coords.inv(P)
Q.hyp.cds <- my.pdisk.coords.inv(Q)
return(my.hyp.dist(P.hyp.cds,Q.hyp.cds))
}
my.hyp.dist3.R <- function(P,Q,Rp,Rq){
P.hyp.cds <- my.pdisk.coords.inv.R(P,Rp)
Q.hyp.cds <- my.pdisk.coords.inv.R(Q,Rq)
return(my.hyp.dist.R(P.hyp.cds,Q.hyp.cds))
}
my.hyp.dist3.R(c(0,0),c(0,0),1,2)
V1
V2
V2 <- c(1,0,2)
P2 <- my.pdisk.coords.R(V2)
P2
my.hyp.dist3.R(P1$u,P2$u,P1$R,P2$R)
my.hyp.dist2(P1$u,P2$u)
my.pdisk.coords.R.inv(P2$u,P1$R)
my.pdisk.coords.inv.R(P2$u,P1$R)
my.pdisk.coords.inv.R(P2$u,P2$R)
my.pdisk.coords.inv.R(P2$u,P1$R) -> P3
my.pdisk.coords.R(P3)
P2
my.hyp.dist.R(V2,P3)
V2
P3
my.hyp.dist(V1,P3)
P1
P3
V3 <- P3
P3 <- my.pdisk.coords.R(V3)
my.hyp.dist3(P1,P3)
my.hyp.dist3.R(P1,P3)
my.hyp.dist3.R(V1,V3)
V1
V3
my.hyp.dist.R(V1,V3)
P1
P3
my.hypdist2(P1$u,P3$u)
my.hyp.dist2(P1$u,P3$u)
V4 <- my.pdisk.coords.inv.R(P1$u,P2$R)
V4
my.hyp.dist.R(V2,V4)
my.hyp.dist2(P2$u,P4$u)
P4 <- my.pisk.coords.R(V4)
P4 <- my.pdisk.coords.R(V4)
my.hyp.dist2(P2$u,P4$u)
my.hyp.dist3(P2$u,P4$u)
my.hyp.dst(V2,V4)
my.hyp.dist(V2,V4)
P2$R
P4$R
my.hyp.dist(V2,V4)
my.hyp.dist2(P2$u,P4$u)
my.hyp.dist2(P2$u,P4$u) * P2$R
my.hyp.dist.R(V2,V4)
V4
V2
my.pdisk.coords.R(V2)
P2
my.pdisk.coords.inv.R(P2$u,P2$R)
V2
plot(cbind(c(1,2),c(P2$u[1],0),c(0,1-),c(0,-P2$R)))
plot(cbind(c(1,2),c(P2$u[1],0),c(0,1-),c(0,-P2$R))
plot(cbind(c(1,2),c(P2$u[1],0),c(0,1-),c(0,-P2$R))))
plot(cbind(c(1,2),c(P2$u[1],0),c(0,-1),c(0,-P2$R))))
plot(cbind(c(1,2),c(P2$u[1],0),c(0,-1),c(0,-P2$R)))
plot(rbind(c(1,2),c(P2$u[1],0),c(0,-1),c(0,-P2$R)))
abline(-1,1)
P2$R^2
-sum(V2*V2)+2*V2[3]*V2[3]
my.hyp.dist(V1,V3)
my.hyp.dist2(P1$u,P3$u)
my.hyp.dist2(P2$u,P4$u)
my.hyp.dist.R(V2,V4)
-sum(V2*V2)+2*V2[3]*V2[3]
-sum(V4*V4)+2*V4[3]*V4[3]
-sum(V2*V4)+2*V2[3]*V4[4]
-sum(V2*V4)+2*V2[3]*V4[3]
(-sum(V2*V4)+2*V2[3]*V4[3] )/3
-sum(V1*V3)+2*V1[3]*V3[3]
# R=1の場合
my.pdisk.coords <- function(x){
x. <- x[1]/(x[3]+1)
y. <- x[2]/(x[3]+1)
return(c(x.,y.))
}
# 円板上の点の座標をx^2 + y^2 - z^2 = -1 という双曲面上に逆写像する
my.pdisk.coords.inv <- function(x){
z <- (1+sum(x^2))/(1-sum(x^2))
tmp <- 2*x/(1-sum(x^2))
return(c(tmp,z))
}
# 任意のRの場合
my.pdisk.coords.R <- function(x){
t <- x[length(x)]
x. <- x[-length(x)]
R <- sqrt(-sum(x^2) + 2 * t^2)
u <- R*x./(R+t)
return(list(u=u,R=R))
}
my.pdisk.coords.inv.R <- function(u,R){
t <- R * (R^2+sum(u^2))/(R^2-sum(u^2))
x. <- 2*R^2*u/(R^2-sum(u^2))
return(c(x.,t))
}
my.hyp.dist1 <- function(P,Q){
out <- my.orth.circle2(P,Q)
r <- out$r
d.ctr <- sqrt(sum(out$ctr^2)) # 原点から測地線円の中心までの距離
theta <- acos(1/d.ctr)
phi <- Arg(out$ctr[1] + 1i * out$ctr[2]) # 測地線円方向の角度
AB1 <- c(cos(phi-theta),sin(phi-theta))
AB2 <- c(cos(phi+theta),sin(phi+theta))
AQ <- sqrt(sum((AB1-Q)^2))
PB <- sqrt(sum((P-AB2)^2))
AP <- sqrt(sum((AB1-P)^2))
QB <- sqrt(sum((Q-AB2)^2))
# A,BをAB1,AB2のどちらにするか、２通りで距離を算出する
dhyp1 <- log(AQ*PB/(AP*QB))
dhyp2 <- log(QB*AP/(PB*AQ))
return(list(dhyp1=dhyp1,dhyp2=dhyp2,A=AB1,B=AB2,circle=out))
}
my.hyp.dist2 <- function(P,Q,r=1){
#r <- 1
PQ <- sqrt(sum((P-Q)^2))
OP <- sqrt(sum((P)^2))
OQ <- sqrt(sum((Q)^2))
dhyp <- acosh(1+2*PQ^2*r^2/((r^2-OP^2)*(r^2-OQ^2)))
return(dhyp)
}
my.hyp.dist <- function(u,v){
acosh(- sum(u*v) + 2*u[length(u)]*v[length(v)])
}
my.hyp.dist.R <- function(u,v){
ip <- - sum(u*v) + 2*u[length(u)]*v[length(v)]
normu <- - sum(u*u) + 2*u[length(u)]*u[length(u)]
normv <- - sum(v*v) + 2*v[length(v)]*v[length(v)]
acosh(ip/sqrt(normu*normv))
}
my.hyp.dist3 <- function(P,Q){
P.hyp.cds <- my.pdisk.coords.inv(P)
Q.hyp.cds <- my.pdisk.coords.inv(Q)
return(my.hyp.dist(P.hyp.cds,Q.hyp.cds))
}
my.hyp.dist3.R <- function(P,Q,Rp,Rq){
P.hyp.cds <- my.pdisk.coords.inv.R(P,Rp)
Q.hyp.cds <- my.pdisk.coords.inv.R(Q,Rq)
return(my.hyp.dist.R(P.hyp.cds,Q.hyp.cds))
}
my.hyp.dist2(P1$u,P3$u)
my.hyp.dist2(P2$u,P4$u,r=P2$R)
P5 <- P4
P5$u <- P4$u * P4$R
P5
P4
P2
P5 <- P2
P5$u <- P2$u*P2$R
P5
my.hyp.dist3.R(P4$u,P5$u,P4$R,P5$R)
my.hyp.dist2(P4$u,P5$u,P4$R)
