c(1,2,3) %x% c(2,3)
p1 <- 1:length(eigen.out1[[1]])
p2 <- 1:length(eigen.out2[[1]])
p12 <- expand.grid(p1,p2)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 * tmp2 # 固有値ペアの積
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
ord12 <- order(evals)evals
p1 <- 1:length(eigen.out1[[1]])
p2 <- 1:length(eigen.out2[[1]])
p12 <- expand.grid(p1,p2)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 * tmp2 # 固有値ペアの積
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
ord12 <- order(evals)
plot(eigen.out12[[1]],evals[ord12])
p1 <- 1:length(eigen.out1[[1]])
p2 <- 1:length(eigen.out2[[1]])
p12 <- expand.grid(p1,p2)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 * tmp2 # 固有値ペアの積
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.out12[[1]],evals[ord12])
p1 <- 1:length(eigen.out1[[1]])
p2 <- 1:length(eigen.out2[[1]])
p12 <- expand.grid(p1,p2)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 * tmp2 # 固有値ペアの積
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.out12[[1]],evals[ord12])
abline(0,1)
p1 <- 1:length(eigen.out1[[1]])
p2 <- 1:length(eigen.out2[[1]])
p12 <- expand.grid(p1,p2)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 * tmp2 # 固有値ペアの積
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.out12[[1]],evals[ord12])
abline(0,1)
range(eigen.out12[[2]] - evecs[,ord12])
p1 <- 1:length(eigen.out1[[1]])
p2 <- 1:length(eigen.out2[[1]])
p12 <- expand.grid(p1,p2)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 * tmp2 # 固有値ペアの積
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.out12[[1]],evals[ord12])
abline(0,1)
eigen.out12[[2]] / evecs[,ord12]
p1 <- 1:length(eigen.out1[[1]])
p2 <- 1:length(eigen.out2[[1]])
p12 <- expand.grid(p1,p2)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 * tmp2 # 固有値ペアの積
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
# 固有値は確かに同じで
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.out12[[1]],evals[ord12])
abline(0,1)
# 固有ベクトルは確かに Mx - lambda x =0を満たす
for(i in 1:length(p12)){
print(range(A12 %*% evecs[,i] - evals[i] * evecs[,i]))
}
p1 <- 1:length(eigen.out1[[1]])
p2 <- 1:length(eigen.out2[[1]])
p12 <- expand.grid(p1,p2)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 * tmp2 # 固有値ペアの積
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
# 固有値は確かに同じで
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.out12[[1]],evals[ord12])
abline(0,1)
# 固有ベクトルは確かに Mx - lambda x =0を満たす
for(i in 1:length(p12[,1])){
print(range(A12 %*% evecs[,i] - evals[i] * evecs[,i]))
}
B12 <- A1 %x% diag(rep(1,length(A2[,1]))) + A2 %x% diag(rep(1,length(A1[,1])))
eigen.outB12 <- eigen(B12)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 + tmp2 # 固有値ペアの積でなく、和
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
# 固有値は確かに同じで
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.outB12[[1]],evals[ord12])
abline(0,1)
# 固有ベクトルは確かに Mx - lambda x =0を満たす
for(i in 1:length(p12[,1])){
print(range(B12 %*% evecs[,i] - evals[i] * evecs[,i]))
}
dim(B12)
B12 <- A1 %x% diag(rep(1,length(A2[,1]))) + A2 %x% diag(rep(1,length(A1[,1])))
plot(graph.adjacency(B12))
eigen.outB12 <- eigen(B12)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 + tmp2 # 固有値ペアの積でなく、和
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
# 固有値は確かに同じで
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.outB12[[1]],evals[ord12])
abline(0,1)
# 固有ベクトルは確かに Mx - lambda x =0を満たす
for(i in 1:length(p12[,1])){
print(range(B12 %*% evecs[,i] - evals[i] * evecs[,i]))
}
B12 <- A1 %x% diag(rep(1,length(A2[,1]))) + diag(rep(1,length(A1[,1])))  %x% A2
plot(graph.adjacency(B12))
eigen.outB12 <- eigen(B12)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 + tmp2 # 固有値ペアの積でなく、和
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
# 固有値は確かに同じで
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.outB12[[1]],evals[ord12])
abline(0,1)
# 固有ベクトルは確かに Mx - lambda x =0を満たす
for(i in 1:length(p12[,1])){
print(range(B12 %*% evecs[,i] - evals[i] * evecs[,i]))
}
D1 <- apply(A1,1,sum)
L1 <- D1 - A1
D2 <- apply(A2,1,sum)
L2 <- D2 - A2
D12 <- apply(B12,1,sum)
L12 <- D12 - B12
eigen.out1 <- eigen(L1)
eigen.out2 <- eigen(L2)
eigen.out12 <- eigen(L12)
evals <- c(rep(eigen.out1[[1]],length(L2[,1])),rep(eigen.out2[[1]],length(L1[,1])))
plot(sort(evals,decreasing=TRUE),eigen.out12[[1]])
dim(B12)
D1 <- diag(apply(A1,1,sum))
L1 <- D1 - A1
D2 <- diag(apply(A2,1,sum))
L2 <- D2 - A2
D12 <- diag(apply(B12,1,sum))
L12 <- D12 - B12
eigen.out1 <- eigen(L1)
eigen.out2 <- eigen(L2)
eigen.out12 <- eigen(L12)
evals <- c(rep(eigen.out1[[1]],length(L2[,1])),rep(eigen.out2[[1]],length(L1[,1])))
plot(sort(evals,decreasing=TRUE),eigen.out12[[1]])
plot(evals)
dim(L1
)
dim(L2)
length(evals)
length(eigen.out12[[1]])
evals <- rep(eigen.out1[[1]],length(L2[,1]))
plot(sort(evals,decreasing=TRUE),eigen.out12[[1]])
evals <- rep(eigen.out1[[1]],length(L2[,1])
plot(sort(evals,decreasing=TRUE),eigen.out12[[1]])
evals <- rep(eigen.out1[[1]],length(L2[,1]))
plot(sort(evals,decreasing=TRUE),eigen.out12[[1]])
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 + tmp2 # 固有値ペアの積でなく、和
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
# 固有値は確かに同じで
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.out12[[1]],evals[ord12])
abline(0,1)
# 固有ベクトルは確かに Mx - lambda x =0を満たす
for(i in 1:length(p12[,1])){
print(range(L12 %*% evecs[,i] - evals[i] * evecs[,i]))
}
B12 <- A1 %x% diag(rep(1,length(A2[,1]))) + diag(rep(1,length(A1[,1])))  %x% A2
plot(graph.adjacency(B12))
eigen.outB12 <- eigen(B12)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 + tmp2 # 固有値ペアの積でなく、和
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
# 固有値は確かに同じで
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.outB12[[1]],evals[ord12])
abline(0,1)
# 固有ベクトルは確かに Mx - lambda x =0を満たす
for(i in 1:length(p12[,1])){
print(range(B12 %*% evecs[,i] - evals[i] * evecs[,i]))
}
B12 <- A1 %x% diag(rep(1,length(A2[,1]))) + diag(rep(1,length(A1[,1])))  %x% A2
plot(graph.adjacency(B12))
eigen.outB12 <- eigen(B12)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 + tmp2 # 固有値ペアの積でなく、和
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
# 固有値は確かに同じで
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.outB12[[1]],evals[ord12])
abline(0,1)
# 固有ベクトルは確かに Mx - lambda x =0を満たす
for(i in 1:length(p12[,1])){
print(range(B12 %*% evecs[,i] - evals[i] * evecs[,i]))
}
eigen.out1 <- eigen(A1)
eigen.out2 <- eigen(A2)
eigen.out12 <- eigen(A12)
p1 <- 1:length(eigen.out1[[1]])
p2 <- 1:length(eigen.out2[[1]])
p12 <- expand.grid(p1,p2)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 * tmp2 # 固有値ペアの積
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
# 固有値は確かに同じで
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.out12[[1]],evals[ord12])
abline(0,1)
# 固有ベクトルは確かに Mx - lambda x =0を満たす
for(i in 1:length(p12[,1])){
print(range(A12 %*% evecs[,i] - evals[i] * evecs[,i]))
}
B12 <- A1 %x% diag(rep(1,length(A2[,1]))) + diag(rep(1,length(A1[,1])))  %x% A2
plot(graph.adjacency(B12))
eigen.outB12 <- eigen(B12)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 + tmp2 # 固有値ペアの積でなく、和
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
# 固有値は確かに同じで
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.outB12[[1]],evals[ord12])
abline(0,1)
# 固有ベクトルは確かに Mx - lambda x =0を満たす
for(i in 1:length(p12[,1])){
print(range(B12 %*% evecs[,i] - evals[i] * evecs[,i]))
}
D1 <- diag(apply(A1,1,sum))
L1 <- D1 - A1
D2 <- diag(apply(A2,1,sum))
L2 <- D2 - A2
D12 <- diag(apply(B12,1,sum))
L12 <- D12 - B12
eigen.out1 <- eigen(L1)
eigen.out2 <- eigen(L2)
eigen.out12 <- eigen(L12)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 + tmp2 # 固有値ペアの積でなく、和
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
# 固有値は確かに同じで
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.out12[[1]],evals[ord12])
abline(0,1)
# 固有ベクトルは確かに Mx - lambda x =0を満たす
for(i in 1:length(p12[,1])){
print(range(L12 %*% evecs[,i] - evals[i] * evecs[,i]))
}
table(eigen.out12[[1]])
plot(eigen.out12[[1]])
eigen.out12[[2]]
eigen.out12[[2]]
image(eigen.out12[[2]])
p1 <- 1:length(eigen.out1[[1]])
p2 <- 1:length(eigen.out2[[1]])
p12 <- expand.grid(p1,p2)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 * tmp2 # 固有値ペアの積
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
# 固有値は確かに同じで
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.out12[[1]],evals[ord12])
abline(0,1)
# 固有ベクトルは確かに Mx - lambda x =0を満たす
for(i in 1:length(p12[,1])){
print(range(A12 %*% evecs[,i] - evals[i] * evecs[,i]))
}
N1 <- solve(D1) %*% A1
N2 <- solve(D2) %*% A2
D12 <- diag(apply(A12,1,sum))
N12 <- solve(D12) %*% A12
eigen.out1 <- eigen(N1)
eigen.out2 <- eigen(N2)
eigen.out12 <- eigen(N12)
p1 <- 1:length(eigen.out1[[1]])
p2 <- 1:length(eigen.out2[[1]])
p12 <- expand.grid(p1,p2)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 * tmp2 # 固有値ペアの積
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
# 固有値は確かに同じで
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.out12[[1]],evals[ord12])
abline(0,1)
# 固有ベクトルは確かに Mx - lambda x =0を満たす
for(i in 1:length(p12[,1])){
print(range(D12 %*% evecs[,i] - evals[i] * evecs[,i]))
}
D1 <- diag(apply(A1,1,sum))
L1 <- D1 - A1
D2 <- diag(apply(A2,1,sum))
L2 <- D2 - A2
D12 <- diag(apply(B12,1,sum))
L12. <- D12 - B12
L12 <- L1 %x% diag(rep(1,length(L2[,1]))) + diag(rep(1,length(L1[,1])))  %x% L2
range(L12. - L12)
eigen.out1 <- eigen(L1)
eigen.out2 <- eigen(L2)
eigen.out12 <- eigen(L12)
N1 <- solve(D1) %*% A1
N2 <- solve(D2) %*% A2
D12 <- diag(apply(A12,1,sum))
N12 <- N1 %x% N2
N12. <- solve(D12) %*% A12
range(N12- N12.)
eigen.out1 <- eigen(N1)
eigen.out2 <- eigen(N2)
eigen.out12 <- eigen(N12)
p1 <- 1:length(eigen.out1[[1]])
p2 <- 1:length(eigen.out2[[1]])
p12 <- expand.grid(p1,p2)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 * tmp2 # 固有値ペアの積
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
# 固有値は確かに同じで
ord12 <- order(evals,decreasing=TRUE)
plot(eigen.out12[[1]],evals[ord12])
abline(0,1)
# 固有ベクトルは確かに Mx - lambda x =0を満たす
for(i in 1:length(p12[,1])){
print(range(N12 %*% evecs[,i] - evals[i] * evecs[,i]))
}
p1 <- 1:length(eigen.out1[[1]])
p2 <- 1:length(eigen.out2[[1]])
p12 <- expand.grid(p1,p2)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 * tmp2 # 固有値ペアの積
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
# 固有値は確かに同じで
ord12 <- order(evals,decreasing=TRUE)
ord12. <- order(eigen.out12[[1]])
plot(eigen.out12[[1]][ord12.],evals[ord12])
abline(0,1)
# 固有ベクトルは確かに Mx - lambda x =0を満たす
for(i in 1:length(p12[,1])){
print(range(N12 %*% evecs[,i] - evals[i] * evecs[,i]))
}
p1 <- 1:length(eigen.out1[[1]])
p2 <- 1:length(eigen.out2[[1]])
p12 <- expand.grid(p1,p2)
evals  <- rep(0,length(p12[,1]))
evecs <- matrix(0,length(p12[,1]),length(p12[,1]))
for(i in 1:length(p12[,1])){
tmp1 <- eigen.out1[[1]][p12[i,1]]
tmp2 <- eigen.out2[[1]][p12[i,2]]
evals[i] <- tmp1 * tmp2 # 固有値ペアの積
tmp1 <- eigen.out1[[2]][,p12[i,1]]
tmp2 <- eigen.out2[[2]][,p12[i,2]]
evecs[,i] <- tmp1 %x% tmp2
}
# 固有値は確かに同じで
ord12 <- order(evals,decreasing=TRUE)
ord12. <- order(eigen.out12[[1]],decreasing=TRUE)
plot(eigen.out12[[1]][ord12.],evals[ord12])
abline(0,1)
# 固有ベクトルは確かに Mx - lambda x =0を満たす
for(i in 1:length(p12[,1])){
print(range(N12 %*% evecs[,i] - evals[i] * evecs[,i]))
}
plot(sort(eigen.out12[[1]]))
eigen.out12[[2]]
image(eigen.out12[[2]])
eigen.out12[[2]]
image(eigen.out12[[2]])
heatmap(eigen.out12[[2]])
